;buildInfoPackage: chisel3, version: 3.4.1, scalaVersion: 2.12.12, sbtVersion: 1.3.10
circuit Buffer : 
  module Buffer : 
    input clock : Clock
    input reset : UInt<1>
    output io : {r_0 : UInt<64>, r_1 : UInt<64>, r_2 : UInt<64>, r_3 : UInt<64>, r_4 : UInt<64>, r_5 : UInt<64>, r_6 : UInt<64>, r_7 : UInt<64>, r_8 : UInt<64>, flip d_0 : UInt<64>, flip d_1 : UInt<64>, flip d_2 : UInt<64>, flip d_3 : UInt<64>, flip d_4 : UInt<64>, flip d_5 : UInt<64>, flip d_6 : UInt<64>, flip d_7 : UInt<64>, flip d_8 : UInt<64>, flip d_9 : UInt<64>, flip w_in : UInt<64>, w_out : UInt<64>, bufferReady : UInt<1>, flip hashReady : UInt<1>, flip dataRead : UInt<1>}
    
    reg bufferReg_1 : UInt<64>, clock @[Buffer.scala 37:24]
    reg bufferReg_2 : UInt<64>, clock @[Buffer.scala 38:24]
    reg bufferReg_3 : UInt<64>, clock @[Buffer.scala 39:24]
    reg bufferReg_4 : UInt<64>, clock @[Buffer.scala 40:24]
    reg bufferReg_5 : UInt<64>, clock @[Buffer.scala 41:24]
    reg bufferReg_6 : UInt<64>, clock @[Buffer.scala 42:24]
    reg bufferReg_7 : UInt<64>, clock @[Buffer.scala 43:24]
    reg bufferReg_8 : UInt<64>, clock @[Buffer.scala 44:24]
    reg bufferReg_9 : UInt<64>, clock @[Buffer.scala 45:24]
    reg counterReg : UInt<4>, clock with : (reset => (reset, UInt<4>("h00"))) @[Buffer.scala 47:27]
    reg stateReg : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Buffer.scala 49:32]
    node _T = eq(UInt<1>("h00"), stateReg) @[Conditional.scala 37:30]
    when _T : @[Conditional.scala 40:58]
      node _T_1 = eq(io.hashReady, UInt<1>("h00")) @[Buffer.scala 55:15]
      when _T_1 : @[Buffer.scala 56:9]
        node _T_2 = lt(counterReg, UInt<4>("h09")) @[Buffer.scala 57:26]
        when _T_2 : @[Buffer.scala 58:11]
          io.bufferReady <= UInt<1>("h00") @[Buffer.scala 59:28]
          node _T_3 = add(counterReg, UInt<1>("h01")) @[Buffer.scala 60:38]
          node _T_4 = tail(_T_3, 1) @[Buffer.scala 60:38]
          counterReg <= _T_4 @[Buffer.scala 60:24]
          stateReg <= UInt<1>("h00") @[Buffer.scala 61:22]
          skip @[Buffer.scala 58:11]
        else : @[Buffer.scala 63:11]
          io.bufferReady <= UInt<1>("h01") @[Buffer.scala 64:28]
          counterReg <= UInt<1>("h00") @[Buffer.scala 65:24]
          stateReg <= UInt<1>("h00") @[Buffer.scala 66:22]
          skip @[Buffer.scala 63:11]
        skip @[Buffer.scala 56:9]
      else : @[Buffer.scala 69:9]
        when io.hashReady : @[Buffer.scala 69:9]
          io.bufferReady <= UInt<1>("h00") @[Buffer.scala 70:26]
          counterReg <= UInt<1>("h00") @[Buffer.scala 71:22]
          stateReg <= UInt<1>("h01") @[Buffer.scala 72:20]
          skip @[Buffer.scala 69:9]
        else : @[Buffer.scala 74:9]
          io.bufferReady <= UInt<1>("h00") @[Buffer.scala 75:26]
          stateReg <= UInt<1>("h00") @[Buffer.scala 76:20]
          counterReg <= UInt<1>("h00") @[Buffer.scala 77:22]
          skip @[Buffer.scala 74:9]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_5 = eq(UInt<1>("h01"), stateReg) @[Conditional.scala 37:30]
      when _T_5 : @[Conditional.scala 39:67]
        counterReg <= UInt<1>("h00") @[Buffer.scala 82:18]
        node _T_6 = and(io.hashReady, io.dataRead) @[Buffer.scala 83:25]
        when _T_6 : @[Buffer.scala 83:40]
          stateReg <= UInt<1>("h00") @[Buffer.scala 85:24]
          skip @[Buffer.scala 83:40]
        else : @[Buffer.scala 86:47]
          node _T_7 = eq(io.dataRead, UInt<1>("h00")) @[Buffer.scala 86:34]
          node _T_8 = and(io.hashReady, _T_7) @[Buffer.scala 86:31]
          when _T_8 : @[Buffer.scala 86:47]
            stateReg <= UInt<1>("h01") @[Buffer.scala 88:24]
            skip @[Buffer.scala 86:47]
          else : @[Buffer.scala 89:18]
            io.bufferReady <= UInt<1>("h00") @[Buffer.scala 91:24]
            stateReg <= UInt<1>("h00") @[Buffer.scala 92:24]
            skip @[Buffer.scala 89:18]
        skip @[Conditional.scala 39:67]
    
